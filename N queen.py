# -*- coding: utf-8 -*-
"""011171202.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1BPwsOiRBIFhQLZeIasCBmoqkHL7i9XbY
"""

import random, copy


class Board:
    def __init__(self, board):
        self.board = board

    def evaluation_function(self):

        # these are separate for easier debugging
        total_cost = 0
        for i in range(0, n):
            for j in range(0, n):
                # if this node is a queen, calculate all violations
                if self.board[i][j] == 1:
                    # calculate how many queens are in the same row with it; this one is done
                    for k in range(0, n):
                        if self.board[i][k] == 1 and k != j:
                            total_cost += 1
                    # calculate how many queens are in the same column with it
                    for k in range (0, n):
                        if self.board[k][j]==1 and k!=i:
                            total_cost += 1

                    # calculate how many queens are in the same diagonal with it
                    for k in range(1, n):
                      if i+k < n and j+k < n:
                       if self.board[i+k][j+k]==1 :
                         total_cost +=1
                      else:
                        break
                    for k in range(1, n):
                      if i+k < n and j-k >=0 :
                        if self.board[i+k][j-k]==1 :
                          total_cost +=1
                      else:
                        break

                    # calculate how many queens are in the same anti-diagonal with it
                    for k in range(1, n):
                      if i-k >= 0 and j-k >= 0:
                        if self.board[i-k][j-k]==1 :
                         total_cost +=1
                      else:
                        break

                    for k in range(1, n):
                      if i-k >= 0 and j+k < n:
                        if self.board[i-k][j+k]==1 :
                          total_cost +=1
                      else:
                        break

                    # sum all the cost and save it to total_cost
        #avg_cost=total_cost/2
        #print("from class total cost: ",avg_cost)
        return total_cost / 2  # why divided with 2? same conflicts counts 2 times

    # define how to print the board; don't change it;
    def __repr__(self):
        matrix = ""
        for i in range(0, n):
            for j in range(0, n):
                matrix = matrix + str(self.board[i][j]) + " "
            matrix = matrix + "\n"
        return matrix


def hill_climbing(board):
    times=0 #work on which col now
    while True:
        #  evaluate(no of conflicts) the cost of the current board; if it is 0, return the board
        #print("hill climbing function : cur state and cost")
        #print(board)
        cost=board.evaluation_function()
        #print("cost (no of conflicts): ",cost)

        if cost==0:
          return board

        # else call the get_a_successor_with_lower_cost() method to get a new board with lower cost
        new_board=get_a_successor_with_lower_cost(board.board, cost,times)

        # if the get_a_successor_with_lower_cost() method returns -1, return "No Solution Found"
        if new_board==-1:
          return "No Solution Found"

        board=Board(new_board)
        times+=1


def get_a_successor_with_lower_cost(board, cost,times):
    cur_board = copy.deepcopy(board)
    # iterate over each element in the board; if the element is a queen, move it to another row on the same column;
    
    found=False
    for col in range(times,n):
      for row in range(0,n):
        if cur_board[row][col]==1:
          for k in range(0,n):
            next_board = copy.deepcopy(cur_board)
            if k!=row :
              next_board[k][col]=1
              next_board[row][col]=0

              child_board = Board(next_board)
              child_board_cost = child_board.evaluation_function()

              if child_board_cost < cost :
                found=True
                return child_board.board

    # check if the cost of the new board is lower than the current one; if it is return the board;
    # if no new state is found with lower cost, return -1
    if found == False:
      return -1


n = int(input())
# 0 matrix
initial_board = [[0 for i in range(0, n)] for j in range(0, n)]
# initialize queens at random places but ensuring only one queen exists in a column
for i in range(0, n):
  #while True:
  rand_row = random.randint(0, n - 1)
  #if initial_board[rand_row][i] == 0:
  initial_board[rand_row][i] = 1
  #break

initialBoard = Board(initial_board)
print("start state: ")
print(initialBoard)
print("final state: ")
print(hill_climbing(initialBoard))
